//
// Copyright (C) 2009 The Libphonenumber Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Definition of protocol buffer for holding metadata for international
// telephone numbers. The fields here correspond exactly to those in
// resources/PhoneNumberMetadata.xml.
// @author Shaopeng Jia

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0-devel
// 	protoc        v3.14.0
// source: phonemetadata.proto

package phonenumbers

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type NumberFormat struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// pattern is a regex that is used to match the national (significant)
	// number. For example, the pattern "(20)(\d{4})(\d{4})" will match number
	// "2070313000", which is the national (significant) number for Google London.
	// Note the presence of the parentheses, which are capturing groups what
	// specifies the grouping of numbers.
	Pattern *string `protobuf:"bytes,1,req,name=pattern" json:"pattern,omitempty"`
	// format specifies how the national (significant) number matched by
	// pattern should be formatted.
	// Using the same example as above, format could contain "$1 $2 $3",
	// meaning that the number should be formatted as "20 7031 3000".
	// Each $x are replaced by the numbers captured by group x in the
	// regex specified by pattern.
	Format *string `protobuf:"bytes,2,req,name=format" json:"format,omitempty"`
	// This field is a regex that is used to match a certain number of digits
	// at the beginning of the national (significant) number. When the match is
	// successful, the accompanying pattern and format should be used to format
	// this number. For example, if leading_digits="[1-3]|44", then all the
	// national numbers starting with 1, 2, 3 or 44 should be formatted using the
	// accompanying pattern and format.
	//
	// The first leadingDigitsPattern matches up to the first three digits of the
	// national (significant) number; the next one matches the first four digits,
	// then the first five and so on, until the leadingDigitsPattern can uniquely
	// identify one pattern and format to be used to format the number.
	//
	// In the case when only one formatting pattern exists, no
	// leading_digits_pattern is needed.
	LeadingDigitsPattern []string `protobuf:"bytes,3,rep,name=leading_digits_pattern,json=leadingDigitsPattern" json:"leading_digits_pattern,omitempty"`
	// This field specifies how the national prefix ($NP) together with the first
	// group ($FG) in the national significant number should be formatted in
	// the NATIONAL format when a national prefix exists for a certain country.
	// For example, when this field contains "($NP$FG)", a number from Beijing,
	// China (whose $NP = 0), which would by default be formatted without
	// national prefix as 10 1234 5678 in NATIONAL format, will instead be
	// formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
	// would contain "($NP)$FG". Note $FG should always be present in this field,
	// but $NP can be omitted. For example, having "$FG" could indicate the
	// number should be formatted in NATIONAL format without the national prefix.
	// This is commonly used to override the rule specified for the territory in
	// the XML file.
	//
	// When this field is missing, a number will be formatted without national
	// prefix in NATIONAL format. This field does not affect how a number
	// is formatted in other formats, such as INTERNATIONAL.
	NationalPrefixFormattingRule *string `protobuf:"bytes,4,opt,name=national_prefix_formatting_rule,json=nationalPrefixFormattingRule" json:"national_prefix_formatting_rule,omitempty"`
	// This field specifies whether the $NP can be omitted when formatting a
	// number in national format, even though it usually wouldn't be. For example,
	// a UK number would be formatted by our library as 020 XXXX XXXX. If we have
	// commonly seen this number written by people without the leading 0, for
	// example as (20) XXXX XXXX, this field would be set to true. This will be
	// inherited from the value set for the territory in the XML file, unless a
	// national_prefix_optional_when_formatting is defined specifically for this
	// NumberFormat.
	NationalPrefixOptionalWhenFormatting *bool `protobuf:"varint,6,opt,name=national_prefix_optional_when_formatting,json=nationalPrefixOptionalWhenFormatting,def=0" json:"national_prefix_optional_when_formatting,omitempty"`
	// This field specifies how any carrier code ($CC) together with the first
	// group ($FG) in the national significant number should be formatted
	// when formatWithCarrierCode is called, if carrier codes are used for a
	// certain country.
	DomesticCarrierCodeFormattingRule *string `protobuf:"bytes,5,opt,name=domestic_carrier_code_formatting_rule,json=domesticCarrierCodeFormattingRule" json:"domestic_carrier_code_formatting_rule,omitempty"`
}

// Default values for NumberFormat fields.
const (
	Default_NumberFormat_NationalPrefixOptionalWhenFormatting = bool(false)
)

func (x *NumberFormat) Reset() {
	*x = NumberFormat{}
	if protoimpl.UnsafeEnabled {
		mi := &file_phonemetadata_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NumberFormat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NumberFormat) ProtoMessage() {}

func (x *NumberFormat) ProtoReflect() protoreflect.Message {
	mi := &file_phonemetadata_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NumberFormat.ProtoReflect.Descriptor instead.
func (*NumberFormat) Descriptor() ([]byte, []int) {
	return file_phonemetadata_proto_rawDescGZIP(), []int{0}
}

func (x *NumberFormat) GetPattern() string {
	if x != nil && x.Pattern != nil {
		return *x.Pattern
	}
	return ""
}

func (x *NumberFormat) GetFormat() string {
	if x != nil && x.Format != nil {
		return *x.Format
	}
	return ""
}

func (x *NumberFormat) GetLeadingDigitsPattern() []string {
	if x != nil {
		return x.LeadingDigitsPattern
	}
	return nil
}

func (x *NumberFormat) GetNationalPrefixFormattingRule() string {
	if x != nil && x.NationalPrefixFormattingRule != nil {
		return *x.NationalPrefixFormattingRule
	}
	return ""
}

func (x *NumberFormat) GetNationalPrefixOptionalWhenFormatting() bool {
	if x != nil && x.NationalPrefixOptionalWhenFormatting != nil {
		return *x.NationalPrefixOptionalWhenFormatting
	}
	return Default_NumberFormat_NationalPrefixOptionalWhenFormatting
}

func (x *NumberFormat) GetDomesticCarrierCodeFormattingRule() string {
	if x != nil && x.DomesticCarrierCodeFormattingRule != nil {
		return *x.DomesticCarrierCodeFormattingRule
	}
	return ""
}

// If you add, remove, or rename fields, or change their semantics, check if you
// should change the excludable field sets or the behavior in MetadataFilter.
type PhoneNumberDesc struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The national_number_pattern is the pattern that a valid national
	// significant number would match. This specifies information such as its
	// total length and leading digits.
	NationalNumberPattern *string `protobuf:"bytes,2,opt,name=national_number_pattern,json=nationalNumberPattern" json:"national_number_pattern,omitempty"`
	// These represent the lengths a phone number from this region can be. They
	// will be sorted from smallest to biggest. Note that these lengths are for
	// the full number, without country calling code or national prefix. For
	// example, for the Swiss number +41789270000, in local format 0789270000,
	// this would be 9.
	// This could be used to highlight tokens in a text that may be a phone
	// number, or to quickly prune numbers that could not possibly be a phone
	// number for this locale.
	PossibleLength []int32 `protobuf:"varint,9,rep,name=possible_length,json=possibleLength" json:"possible_length,omitempty"`
	// These represent the lengths that only local phone numbers (without an area
	// code) from this region can be. They will be sorted from smallest to
	// biggest. For example, since the American number 456-1234 may be locally
	// diallable, although not diallable from outside the area, 7 could be a
	// possible value.
	// This could be used to highlight tokens in a text that may be a phone
	// number.
	// To our knowledge, area codes are usually only relevant for some fixed-line
	// and mobile numbers, so this field should only be set for those types of
	// numbers (and the general description) - however there are exceptions for
	// NANPA countries.
	// This data is used to calculate whether a number could be a possible number
	// for a particular type.
	PossibleLengthLocalOnly []int32 `protobuf:"varint,10,rep,name=possible_length_local_only,json=possibleLengthLocalOnly" json:"possible_length_local_only,omitempty"`
	// An example national significant number for the specific type. It should
	// not contain any formatting information.
	ExampleNumber *string `protobuf:"bytes,6,opt,name=example_number,json=exampleNumber" json:"example_number,omitempty"`
}

func (x *PhoneNumberDesc) Reset() {
	*x = PhoneNumberDesc{}
	if protoimpl.UnsafeEnabled {
		mi := &file_phonemetadata_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PhoneNumberDesc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhoneNumberDesc) ProtoMessage() {}

func (x *PhoneNumberDesc) ProtoReflect() protoreflect.Message {
	mi := &file_phonemetadata_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhoneNumberDesc.ProtoReflect.Descriptor instead.
func (*PhoneNumberDesc) Descriptor() ([]byte, []int) {
	return file_phonemetadata_proto_rawDescGZIP(), []int{1}
}

func (x *PhoneNumberDesc) GetNationalNumberPattern() string {
	if x != nil && x.NationalNumberPattern != nil {
		return *x.NationalNumberPattern
	}
	return ""
}

func (x *PhoneNumberDesc) GetPossibleLength() []int32 {
	if x != nil {
		return x.PossibleLength
	}
	return nil
}

func (x *PhoneNumberDesc) GetPossibleLengthLocalOnly() []int32 {
	if x != nil {
		return x.PossibleLengthLocalOnly
	}
	return nil
}

func (x *PhoneNumberDesc) GetExampleNumber() string {
	if x != nil && x.ExampleNumber != nil {
		return *x.ExampleNumber
	}
	return ""
}

// If you add, remove, or rename fields, or change their semantics, check if you
// should change the excludable field sets or the behavior in MetadataFilter.
type PhoneMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The general_desc contains information which is a superset of descriptions
	// for all types of phone numbers. If any element is missing in the
	// description of a specific type in the XML file, the element will inherit
	// from its counterpart in the general_desc. For all types that are generally
	// relevant to normal phone numbers, if the whole type is missing in the
	// PhoneNumberMetadata XML file, it will not have national number data, and
	// the possible lengths will be [-1].
	GeneralDesc     *PhoneNumberDesc `protobuf:"bytes,1,opt,name=general_desc,json=generalDesc" json:"general_desc,omitempty"`
	FixedLine       *PhoneNumberDesc `protobuf:"bytes,2,opt,name=fixed_line,json=fixedLine" json:"fixed_line,omitempty"`
	Mobile          *PhoneNumberDesc `protobuf:"bytes,3,opt,name=mobile" json:"mobile,omitempty"`
	TollFree        *PhoneNumberDesc `protobuf:"bytes,4,opt,name=toll_free,json=tollFree" json:"toll_free,omitempty"`
	PremiumRate     *PhoneNumberDesc `protobuf:"bytes,5,opt,name=premium_rate,json=premiumRate" json:"premium_rate,omitempty"`
	SharedCost      *PhoneNumberDesc `protobuf:"bytes,6,opt,name=shared_cost,json=sharedCost" json:"shared_cost,omitempty"`
	PersonalNumber  *PhoneNumberDesc `protobuf:"bytes,7,opt,name=personal_number,json=personalNumber" json:"personal_number,omitempty"`
	Voip            *PhoneNumberDesc `protobuf:"bytes,8,opt,name=voip" json:"voip,omitempty"`
	Pager           *PhoneNumberDesc `protobuf:"bytes,21,opt,name=pager" json:"pager,omitempty"`
	Uan             *PhoneNumberDesc `protobuf:"bytes,25,opt,name=uan" json:"uan,omitempty"`
	Emergency       *PhoneNumberDesc `protobuf:"bytes,27,opt,name=emergency" json:"emergency,omitempty"`
	Voicemail       *PhoneNumberDesc `protobuf:"bytes,28,opt,name=voicemail" json:"voicemail,omitempty"`
	ShortCode       *PhoneNumberDesc `protobuf:"bytes,29,opt,name=short_code,json=shortCode" json:"short_code,omitempty"`
	StandardRate    *PhoneNumberDesc `protobuf:"bytes,30,opt,name=standard_rate,json=standardRate" json:"standard_rate,omitempty"`
	CarrierSpecific *PhoneNumberDesc `protobuf:"bytes,31,opt,name=carrier_specific,json=carrierSpecific" json:"carrier_specific,omitempty"`
	SmsServices     *PhoneNumberDesc `protobuf:"bytes,33,opt,name=sms_services,json=smsServices" json:"sms_services,omitempty"`
	// The rules here distinguish the numbers that are only able to be dialled
	// nationally.
	NoInternationalDialling *PhoneNumberDesc `protobuf:"bytes,24,opt,name=no_international_dialling,json=noInternationalDialling" json:"no_international_dialling,omitempty"`
	// The CLDR 2-letter representation of a country/region, with the exception of
	// "country calling codes" used for non-geographical entities, such as
	// Universal International Toll Free Number (+800). These are all given the ID
	// "001", since this is the numeric region code for the world according to UN
	// M.49: http://en.wikipedia.org/wiki/UN_M.49
	Id *string `protobuf:"bytes,9,req,name=id" json:"id,omitempty"`
	// The country calling code that one would dial from overseas when trying to
	// dial a phone number in this country. For example, this would be "64" for
	// New Zealand.
	CountryCode *int32 `protobuf:"varint,10,opt,name=country_code,json=countryCode" json:"country_code,omitempty"`
	// The international_prefix of country A is the number that needs to be
	// dialled from country A to another country (country B). This is followed
	// by the country code for country B. Note that some countries may have more
	// than one international prefix, and for those cases, a regular expression
	// matching the international prefixes will be stored in this field.
	InternationalPrefix *string `protobuf:"bytes,11,opt,name=international_prefix,json=internationalPrefix" json:"international_prefix,omitempty"`
	// If more than one international prefix is present, a preferred prefix can
	// be specified here for out-of-country formatting purposes. If this field is
	// not present, and multiple international prefixes are present, then "+"
	// will be used instead.
	PreferredInternationalPrefix *string `protobuf:"bytes,17,opt,name=preferred_international_prefix,json=preferredInternationalPrefix" json:"preferred_international_prefix,omitempty"`
	// The national prefix of country A is the number that needs to be dialled
	// before the national significant number when dialling internally. This
	// would not be dialled when dialling internationally. For example, in New
	// Zealand, the number that would be locally dialled as 09 345 3456 would be
	// dialled from overseas as +64 9 345 3456. In this case, 0 is the national
	// prefix.
	NationalPrefix *string `protobuf:"bytes,12,opt,name=national_prefix,json=nationalPrefix" json:"national_prefix,omitempty"`
	// The preferred prefix when specifying an extension in this country. This is
	// used for formatting only, and if this is not specified, a suitable default
	// should be used instead. For example, if you wanted extensions to be
	// formatted in the following way:
	// 1 (365) 345 445 ext. 2345
	// " ext. "  should be the preferred extension prefix.
	PreferredExtnPrefix *string `protobuf:"bytes,13,opt,name=preferred_extn_prefix,json=preferredExtnPrefix" json:"preferred_extn_prefix,omitempty"`
	// This field is used for cases where the national prefix of a country
	// contains a carrier selection code, and is written in the form of a
	// regular expression. For example, to dial the number 2222-2222 in
	// Fortaleza, Brazil (area code 85) using the long distance carrier Oi
	// (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
	// only other possible carrier selection code is 32, the field will
	// contain "03[12]".
	//
	// When it is missing from the XML file, this field inherits the value of
	// national_prefix, if that is present.
	NationalPrefixForParsing *string `protobuf:"bytes,15,opt,name=national_prefix_for_parsing,json=nationalPrefixForParsing" json:"national_prefix_for_parsing,omitempty"`
	// This field is only populated and used under very rare situations.
	// For example, mobile numbers in Argentina are written in two completely
	// different ways when dialed in-country and out-of-country
	// (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
	// This field is used together with national_prefix_for_parsing to transform
	// the number into a particular representation for storing in the phonenumber
	// proto buffer in those rare cases.
	NationalPrefixTransformRule *string `protobuf:"bytes,16,opt,name=national_prefix_transform_rule,json=nationalPrefixTransformRule" json:"national_prefix_transform_rule,omitempty"`
	// Specifies whether the mobile and fixed-line patterns are the same or not.
	// This is used to speed up determining phone number type in countries where
	// these two types of phone numbers can never be distinguished.
	SameMobileAndFixedLinePattern *bool `protobuf:"varint,18,opt,name=same_mobile_and_fixed_line_pattern,json=sameMobileAndFixedLinePattern,def=0" json:"same_mobile_and_fixed_line_pattern,omitempty"`
	// Note that the number format here is used for formatting only, not parsing.
	// Hence all the varied ways a user *may* write a number need not be recorded
	// - just the ideal way we would like to format it for them. When this element
	// is absent, the national significant number will be formatted as a whole
	// without any formatting applied.
	NumberFormat []*NumberFormat `protobuf:"bytes,19,rep,name=number_format,json=numberFormat" json:"number_format,omitempty"`
	// This field is populated only when the national significant number is
	// formatted differently when it forms part of the INTERNATIONAL format
	// and NATIONAL format. A case in point is mobile numbers in Argentina:
	// The number, which would be written in INTERNATIONAL format as
	// +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
	// format. In this case, the prefix 9 is inserted when dialling from
	// overseas, but otherwise the prefix 0 and the carrier selection code
	// 15 (inserted after the area code of 343) is used.
	// Note: this field is populated by setting a value for <intlFormat> inside
	// the <numberFormat> tag in the XML file. If <intlFormat> is not set then it
	// defaults to the same value as the <format> tag.
	//
	// Examples:
	//   To set the <intlFormat> to a different value than the <format>:
	//     <numberFormat pattern=....>
	//       <format>$1 $2 $3</format>
	//       <intlFormat>$1-$2-$3</intlFormat>
	//     </numberFormat>
	//
	//   To have a format only used for national formatting, set <intlFormat> to
	//   "NA":
	//     <numberFormat pattern=....>
	//       <format>$1 $2 $3</format>
	//       <intlFormat>NA</intlFormat>
	//     </numberFormat>
	IntlNumberFormat []*NumberFormat `protobuf:"bytes,20,rep,name=intl_number_format,json=intlNumberFormat" json:"intl_number_format,omitempty"`
	// This field is set when this country is considered to be the main country
	// for a calling code. It may not be set by more than one country with the
	// same calling code, and it should not be set by countries with a unique
	// calling code. This can be used to indicate that "GB" is the main country
	// for the calling code "44" for example, rather than Jersey or the Isle of
	// Man.
	MainCountryForCode *bool `protobuf:"varint,22,opt,name=main_country_for_code,json=mainCountryForCode,def=0" json:"main_country_for_code,omitempty"`
	// This field is populated only for countries or regions that share a country
	// calling code. If a number matches this pattern, it could belong to this
	// region. This is not intended as a replacement for IsValidForRegion since a
	// matching prefix is insufficient for a number to be valid. Furthermore, it
	// does not contain all the prefixes valid for a region - for example, 800
	// numbers are valid for all NANPA countries and are hence not listed here.
	// This field should be a regular expression of the expected prefix match.
	// It is used merely as a short-cut for working out which region a number
	// comes from in the case that there is only one, so leading_digit prefixes
	// should not overlap.
	LeadingDigits *string `protobuf:"bytes,23,opt,name=leading_digits,json=leadingDigits" json:"leading_digits,omitempty"`
	// Deprecated: do not use. Will be deletd when there are no references to this
	// later.
	LeadingZeroPossible *bool `protobuf:"varint,26,opt,name=leading_zero_possible,json=leadingZeroPossible,def=0" json:"leading_zero_possible,omitempty"`
	// This field is set when this country has implemented mobile number
	// portability. This means that transferring mobile numbers between carriers
	// is allowed. A consequence of this is that phone prefix to carrier mapping
	// is less reliable.
	MobileNumberPortableRegion *bool `protobuf:"varint,32,opt,name=mobile_number_portable_region,json=mobileNumberPortableRegion,def=0" json:"mobile_number_portable_region,omitempty"`
}

// Default values for PhoneMetadata fields.
const (
	Default_PhoneMetadata_SameMobileAndFixedLinePattern = bool(false)
	Default_PhoneMetadata_MainCountryForCode            = bool(false)
	Default_PhoneMetadata_LeadingZeroPossible           = bool(false)
	Default_PhoneMetadata_MobileNumberPortableRegion    = bool(false)
)

func (x *PhoneMetadata) Reset() {
	*x = PhoneMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_phonemetadata_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PhoneMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhoneMetadata) ProtoMessage() {}

func (x *PhoneMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_phonemetadata_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhoneMetadata.ProtoReflect.Descriptor instead.
func (*PhoneMetadata) Descriptor() ([]byte, []int) {
	return file_phonemetadata_proto_rawDescGZIP(), []int{2}
}

func (x *PhoneMetadata) GetGeneralDesc() *PhoneNumberDesc {
	if x != nil {
		return x.GeneralDesc
	}
	return nil
}

func (x *PhoneMetadata) GetFixedLine() *PhoneNumberDesc {
	if x != nil {
		return x.FixedLine
	}
	return nil
}

func (x *PhoneMetadata) GetMobile() *PhoneNumberDesc {
	if x != nil {
		return x.Mobile
	}
	return nil
}

func (x *PhoneMetadata) GetTollFree() *PhoneNumberDesc {
	if x != nil {
		return x.TollFree
	}
	return nil
}

func (x *PhoneMetadata) GetPremiumRate() *PhoneNumberDesc {
	if x != nil {
		return x.PremiumRate
	}
	return nil
}

func (x *PhoneMetadata) GetSharedCost() *PhoneNumberDesc {
	if x != nil {
		return x.SharedCost
	}
	return nil
}

func (x *PhoneMetadata) GetPersonalNumber() *PhoneNumberDesc {
	if x != nil {
		return x.PersonalNumber
	}
	return nil
}

func (x *PhoneMetadata) GetVoip() *PhoneNumberDesc {
	if x != nil {
		return x.Voip
	}
	return nil
}

func (x *PhoneMetadata) GetPager() *PhoneNumberDesc {
	if x != nil {
		return x.Pager
	}
	return nil
}

func (x *PhoneMetadata) GetUan() *PhoneNumberDesc {
	if x != nil {
		return x.Uan
	}
	return nil
}

func (x *PhoneMetadata) GetEmergency() *PhoneNumberDesc {
	if x != nil {
		return x.Emergency
	}
	return nil
}

func (x *PhoneMetadata) GetVoicemail() *PhoneNumberDesc {
	if x != nil {
		return x.Voicemail
	}
	return nil
}

func (x *PhoneMetadata) GetShortCode() *PhoneNumberDesc {
	if x != nil {
		return x.ShortCode
	}
	return nil
}

func (x *PhoneMetadata) GetStandardRate() *PhoneNumberDesc {
	if x != nil {
		return x.StandardRate
	}
	return nil
}

func (x *PhoneMetadata) GetCarrierSpecific() *PhoneNumberDesc {
	if x != nil {
		return x.CarrierSpecific
	}
	return nil
}

func (x *PhoneMetadata) GetSmsServices() *PhoneNumberDesc {
	if x != nil {
		return x.SmsServices
	}
	return nil
}

func (x *PhoneMetadata) GetNoInternationalDialling() *PhoneNumberDesc {
	if x != nil {
		return x.NoInternationalDialling
	}
	return nil
}

func (x *PhoneMetadata) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *PhoneMetadata) GetCountryCode() int32 {
	if x != nil && x.CountryCode != nil {
		return *x.CountryCode
	}
	return 0
}

func (x *PhoneMetadata) GetInternationalPrefix() string {
	if x != nil && x.InternationalPrefix != nil {
		return *x.InternationalPrefix
	}
	return ""
}

func (x *PhoneMetadata) GetPreferredInternationalPrefix() string {
	if x != nil && x.PreferredInternationalPrefix != nil {
		return *x.PreferredInternationalPrefix
	}
	return ""
}

func (x *PhoneMetadata) GetNationalPrefix() string {
	if x != nil && x.NationalPrefix != nil {
		return *x.NationalPrefix
	}
	return ""
}

func (x *PhoneMetadata) GetPreferredExtnPrefix() string {
	if x != nil && x.PreferredExtnPrefix != nil {
		return *x.PreferredExtnPrefix
	}
	return ""
}

func (x *PhoneMetadata) GetNationalPrefixForParsing() string {
	if x != nil && x.NationalPrefixForParsing != nil {
		return *x.NationalPrefixForParsing
	}
	return ""
}

func (x *PhoneMetadata) GetNationalPrefixTransformRule() string {
	if x != nil && x.NationalPrefixTransformRule != nil {
		return *x.NationalPrefixTransformRule
	}
	return ""
}

func (x *PhoneMetadata) GetSameMobileAndFixedLinePattern() bool {
	if x != nil && x.SameMobileAndFixedLinePattern != nil {
		return *x.SameMobileAndFixedLinePattern
	}
	return Default_PhoneMetadata_SameMobileAndFixedLinePattern
}

func (x *PhoneMetadata) GetNumberFormat() []*NumberFormat {
	if x != nil {
		return x.NumberFormat
	}
	return nil
}

func (x *PhoneMetadata) GetIntlNumberFormat() []*NumberFormat {
	if x != nil {
		return x.IntlNumberFormat
	}
	return nil
}

func (x *PhoneMetadata) GetMainCountryForCode() bool {
	if x != nil && x.MainCountryForCode != nil {
		return *x.MainCountryForCode
	}
	return Default_PhoneMetadata_MainCountryForCode
}

func (x *PhoneMetadata) GetLeadingDigits() string {
	if x != nil && x.LeadingDigits != nil {
		return *x.LeadingDigits
	}
	return ""
}

func (x *PhoneMetadata) GetLeadingZeroPossible() bool {
	if x != nil && x.LeadingZeroPossible != nil {
		return *x.LeadingZeroPossible
	}
	return Default_PhoneMetadata_LeadingZeroPossible
}

func (x *PhoneMetadata) GetMobileNumberPortableRegion() bool {
	if x != nil && x.MobileNumberPortableRegion != nil {
		return *x.MobileNumberPortableRegion
	}
	return Default_PhoneMetadata_MobileNumberPortableRegion
}

type PhoneMetadataCollection struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Metadata []*PhoneMetadata `protobuf:"bytes,1,rep,name=metadata" json:"metadata,omitempty"`
}

func (x *PhoneMetadataCollection) Reset() {
	*x = PhoneMetadataCollection{}
	if protoimpl.UnsafeEnabled {
		mi := &file_phonemetadata_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PhoneMetadataCollection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhoneMetadataCollection) ProtoMessage() {}

func (x *PhoneMetadataCollection) ProtoReflect() protoreflect.Message {
	mi := &file_phonemetadata_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhoneMetadataCollection.ProtoReflect.Descriptor instead.
func (*PhoneMetadataCollection) Descriptor() ([]byte, []int) {
	return file_phonemetadata_proto_rawDescGZIP(), []int{3}
}

func (x *PhoneMetadataCollection) GetMetadata() []*PhoneMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

var File_phonemetadata_proto protoreflect.FileDescriptor

var file_phonemetadata_proto_rawDesc = []byte{
	0x0a, 0x13, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62,
	0x65, 0x72, 0x73, 0x22, 0xee, 0x02, 0x0a, 0x0c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x46, 0x6f,
	0x72, 0x6d, 0x61, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x18,
	0x01, 0x20, 0x02, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x12, 0x16,
	0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x52, 0x06,
	0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x34, 0x0a, 0x16, 0x6c, 0x65, 0x61, 0x64, 0x69, 0x6e,
	0x67, 0x5f, 0x64, 0x69, 0x67, 0x69, 0x74, 0x73, 0x5f, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x14, 0x6c, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x44,
	0x69, 0x67, 0x69, 0x74, 0x73, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x12, 0x45, 0x0a, 0x1f,
	0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x5f,
	0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x72, 0x75, 0x6c, 0x65, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x1c, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x52,
	0x75, 0x6c, 0x65, 0x12, 0x5d, 0x0a, 0x28, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f,
	0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f,
	0x77, 0x68, 0x65, 0x6e, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x24, 0x6e, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4f, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x61, 0x6c, 0x57, 0x68, 0x65, 0x6e, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x69,
	0x6e, 0x67, 0x12, 0x50, 0x0a, 0x25, 0x64, 0x6f, 0x6d, 0x65, 0x73, 0x74, 0x69, 0x63, 0x5f, 0x63,
	0x61, 0x72, 0x72, 0x69, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x6d,
	0x61, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x72, 0x75, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x21, 0x64, 0x6f, 0x6d, 0x65, 0x73, 0x74, 0x69, 0x63, 0x43, 0x61, 0x72, 0x72, 0x69,
	0x65, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x74, 0x69, 0x6e, 0x67,
	0x52, 0x75, 0x6c, 0x65, 0x22, 0xd6, 0x01, 0x0a, 0x0f, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75,
	0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x12, 0x36, 0x0a, 0x17, 0x6e, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x74, 0x74,
	0x65, 0x72, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x6e, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
	0x12, 0x27, 0x0a, 0x0f, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x5f, 0x6c, 0x65, 0x6e,
	0x67, 0x74, 0x68, 0x18, 0x09, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0e, 0x70, 0x6f, 0x73, 0x73, 0x69,
	0x62, 0x6c, 0x65, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x3b, 0x0a, 0x1a, 0x70, 0x6f, 0x73,
	0x73, 0x69, 0x62, 0x6c, 0x65, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x5f, 0x6c, 0x6f, 0x63,
	0x61, 0x6c, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x05, 0x52, 0x17, 0x70,
	0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x4c, 0x6f, 0x63,
	0x61, 0x6c, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x25, 0x0a, 0x0e, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c,
	0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d,
	0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x22, 0x98, 0x0f,
	0x0a, 0x0d, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12,
	0x40, 0x0a, 0x0c, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d,
	0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72,
	0x44, 0x65, 0x73, 0x63, 0x52, 0x0b, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x44, 0x65, 0x73,
	0x63, 0x12, 0x3c, 0x0a, 0x0a, 0x66, 0x69, 0x78, 0x65, 0x64, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d,
	0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72,
	0x44, 0x65, 0x73, 0x63, 0x52, 0x09, 0x66, 0x69, 0x78, 0x65, 0x64, 0x4c, 0x69, 0x6e, 0x65, 0x12,
	0x35, 0x0a, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50,
	0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x06,
	0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x12, 0x3a, 0x0a, 0x09, 0x74, 0x6f, 0x6c, 0x6c, 0x5f, 0x66,
	0x72, 0x65, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e,
	0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75,
	0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x08, 0x74, 0x6f, 0x6c, 0x6c, 0x46, 0x72,
	0x65, 0x65, 0x12, 0x40, 0x0a, 0x0c, 0x70, 0x72, 0x65, 0x6d, 0x69, 0x75, 0x6d, 0x5f, 0x72, 0x61,
	0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65,
	0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d,
	0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x0b, 0x70, 0x72, 0x65, 0x6d, 0x69, 0x75, 0x6d,
	0x52, 0x61, 0x74, 0x65, 0x12, 0x3e, 0x0a, 0x0b, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64, 0x5f, 0x63,
	0x6f, 0x73, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e,
	0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75,
	0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x0a, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64,
	0x43, 0x6f, 0x73, 0x74, 0x12, 0x46, 0x0a, 0x0f, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x6c,
	0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e,
	0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f,
	0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x0e, 0x70, 0x65,
	0x72, 0x73, 0x6f, 0x6e, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x31, 0x0a, 0x04,
	0x76, 0x6f, 0x69, 0x70, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f,
	0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e,
	0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x04, 0x76, 0x6f, 0x69, 0x70, 0x12,
	0x33, 0x0a, 0x05, 0x70, 0x61, 0x67, 0x65, 0x72, 0x18, 0x15, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d,
	0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68,
	0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x05, 0x70,
	0x61, 0x67, 0x65, 0x72, 0x12, 0x2f, 0x0a, 0x03, 0x75, 0x61, 0x6e, 0x18, 0x19, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73,
	0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63,
	0x52, 0x03, 0x75, 0x61, 0x6e, 0x12, 0x3b, 0x0a, 0x09, 0x65, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x6e,
	0x63, 0x79, 0x18, 0x1b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65,
	0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d,
	0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x09, 0x65, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x6e,
	0x63, 0x79, 0x12, 0x3b, 0x0a, 0x09, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18,
	0x1c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d,
	0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72,
	0x44, 0x65, 0x73, 0x63, 0x52, 0x09, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12,
	0x3c, 0x0a, 0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x1d, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65,
	0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65,
	0x73, 0x63, 0x52, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x42, 0x0a,
	0x0d, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x1e,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62,
	0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44,
	0x65, 0x73, 0x63, 0x52, 0x0c, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x52, 0x61, 0x74,
	0x65, 0x12, 0x48, 0x0a, 0x10, 0x63, 0x61, 0x72, 0x72, 0x69, 0x65, 0x72, 0x5f, 0x73, 0x70, 0x65,
	0x63, 0x69, 0x66, 0x69, 0x63, 0x18, 0x1f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68,
	0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65,
	0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52, 0x0f, 0x63, 0x61, 0x72, 0x72,
	0x69, 0x65, 0x72, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x12, 0x40, 0x0a, 0x0c, 0x73,
	0x6d, 0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x18, 0x21, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73,
	0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63,
	0x52, 0x0b, 0x73, 0x6d, 0x73, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x12, 0x59, 0x0a,
	0x19, 0x6e, 0x6f, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61,
	0x6c, 0x5f, 0x64, 0x69, 0x61, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1d, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e,
	0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x44, 0x65, 0x73, 0x63, 0x52,
	0x17, 0x6e, 0x6f, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c,
	0x44, 0x69, 0x61, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x09,
	0x20, 0x02, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x63, 0x6f, 0x75, 0x6e,
	0x74, 0x72, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b,
	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x31, 0x0a, 0x14, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x65,
	0x66, 0x69, 0x78, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x13, 0x69, 0x6e, 0x74, 0x65, 0x72,
	0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x44,
	0x0a, 0x1e, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x5f, 0x69, 0x6e, 0x74, 0x65,
	0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78,
	0x18, 0x11, 0x20, 0x01, 0x28, 0x09, 0x52, 0x1c, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65,
	0x64, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72,
	0x65, 0x66, 0x69, 0x78, 0x12, 0x27, 0x0a, 0x0f, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c,
	0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x6e,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x32, 0x0a,
	0x15, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x5f, 0x65, 0x78, 0x74, 0x6e, 0x5f,
	0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x13, 0x70, 0x72,
	0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x45, 0x78, 0x74, 0x6e, 0x50, 0x72, 0x65, 0x66, 0x69,
	0x78, 0x12, 0x3d, 0x0a, 0x1b, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x70, 0x72,
	0x65, 0x66, 0x69, 0x78, 0x5f, 0x66, 0x6f, 0x72, 0x5f, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6e, 0x67,
	0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x52, 0x18, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c,
	0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x46, 0x6f, 0x72, 0x50, 0x61, 0x72, 0x73, 0x69, 0x6e, 0x67,
	0x12, 0x43, 0x0a, 0x1e, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x65,
	0x66, 0x69, 0x78, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x5f, 0x72, 0x75,
	0x6c, 0x65, 0x18, 0x10, 0x20, 0x01, 0x28, 0x09, 0x52, 0x1b, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x61, 0x6c, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72,
	0x6d, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x50, 0x0a, 0x22, 0x73, 0x61, 0x6d, 0x65, 0x5f, 0x6d, 0x6f,
	0x62, 0x69, 0x6c, 0x65, 0x5f, 0x61, 0x6e, 0x64, 0x5f, 0x66, 0x69, 0x78, 0x65, 0x64, 0x5f, 0x6c,
	0x69, 0x6e, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x18, 0x12, 0x20, 0x01, 0x28,
	0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x1d, 0x73, 0x61, 0x6d, 0x65, 0x4d, 0x6f,
	0x62, 0x69, 0x6c, 0x65, 0x41, 0x6e, 0x64, 0x46, 0x69, 0x78, 0x65, 0x64, 0x4c, 0x69, 0x6e, 0x65,
	0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x12, 0x3f, 0x0a, 0x0d, 0x6e, 0x75, 0x6d, 0x62, 0x65,
	0x72, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x13, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x4e, 0x75,
	0x6d, 0x62, 0x65, 0x72, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x0c, 0x6e, 0x75, 0x6d, 0x62,
	0x65, 0x72, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x48, 0x0a, 0x12, 0x69, 0x6e, 0x74, 0x6c,
	0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x14,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62,
	0x65, 0x72, 0x73, 0x2e, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
	0x52, 0x10, 0x69, 0x6e, 0x74, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x46, 0x6f, 0x72, 0x6d,
	0x61, 0x74, 0x12, 0x38, 0x0a, 0x15, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x72, 0x79, 0x5f, 0x66, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x16, 0x20, 0x01, 0x28,
	0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x12, 0x6d, 0x61, 0x69, 0x6e, 0x43, 0x6f,
	0x75, 0x6e, 0x74, 0x72, 0x79, 0x46, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x25, 0x0a, 0x0e,
	0x6c, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x64, 0x69, 0x67, 0x69, 0x74, 0x73, 0x18, 0x17,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6c, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x44, 0x69, 0x67,
	0x69, 0x74, 0x73, 0x12, 0x39, 0x0a, 0x15, 0x6c, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x7a,
	0x65, 0x72, 0x6f, 0x5f, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x18, 0x1a, 0x20, 0x01,
	0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x13, 0x6c, 0x65, 0x61, 0x64, 0x69,
	0x6e, 0x67, 0x5a, 0x65, 0x72, 0x6f, 0x50, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x12, 0x48,
	0x0a, 0x1d, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x5f,
	0x70, 0x6f, 0x72, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18,
	0x20, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x1a, 0x6d, 0x6f,
	0x62, 0x69, 0x6c, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x61, 0x62,
	0x6c, 0x65, 0x52, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x22, 0x52, 0x0a, 0x17, 0x50, 0x68, 0x6f, 0x6e,
	0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x37, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d,
	0x62, 0x65, 0x72, 0x73, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x42, 0x20, 0x0a, 0x1c,
	0x63, 0x6f, 0x6d, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x69, 0x31, 0x38, 0x6e, 0x2e,
	0x70, 0x68, 0x6f, 0x6e, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x48, 0x03,
}

var (
	file_phonemetadata_proto_rawDescOnce sync.Once
	file_phonemetadata_proto_rawDescData = file_phonemetadata_proto_rawDesc
)

func file_phonemetadata_proto_rawDescGZIP() []byte {
	file_phonemetadata_proto_rawDescOnce.Do(func() {
		file_phonemetadata_proto_rawDescData = protoimpl.X.CompressGZIP(file_phonemetadata_proto_rawDescData)
	})
	return file_phonemetadata_proto_rawDescData
}

var file_phonemetadata_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_phonemetadata_proto_goTypes = []interface{}{
	(*NumberFormat)(nil),            // 0: phonenumbers.NumberFormat
	(*PhoneNumberDesc)(nil),         // 1: phonenumbers.PhoneNumberDesc
	(*PhoneMetadata)(nil),           // 2: phonenumbers.PhoneMetadata
	(*PhoneMetadataCollection)(nil), // 3: phonenumbers.PhoneMetadataCollection
}
var file_phonemetadata_proto_depIdxs = []int32{
	1,  // 0: phonenumbers.PhoneMetadata.general_desc:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 1: phonenumbers.PhoneMetadata.fixed_line:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 2: phonenumbers.PhoneMetadata.mobile:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 3: phonenumbers.PhoneMetadata.toll_free:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 4: phonenumbers.PhoneMetadata.premium_rate:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 5: phonenumbers.PhoneMetadata.shared_cost:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 6: phonenumbers.PhoneMetadata.personal_number:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 7: phonenumbers.PhoneMetadata.voip:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 8: phonenumbers.PhoneMetadata.pager:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 9: phonenumbers.PhoneMetadata.uan:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 10: phonenumbers.PhoneMetadata.emergency:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 11: phonenumbers.PhoneMetadata.voicemail:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 12: phonenumbers.PhoneMetadata.short_code:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 13: phonenumbers.PhoneMetadata.standard_rate:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 14: phonenumbers.PhoneMetadata.carrier_specific:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 15: phonenumbers.PhoneMetadata.sms_services:type_name -> phonenumbers.PhoneNumberDesc
	1,  // 16: phonenumbers.PhoneMetadata.no_international_dialling:type_name -> phonenumbers.PhoneNumberDesc
	0,  // 17: phonenumbers.PhoneMetadata.number_format:type_name -> phonenumbers.NumberFormat
	0,  // 18: phonenumbers.PhoneMetadata.intl_number_format:type_name -> phonenumbers.NumberFormat
	2,  // 19: phonenumbers.PhoneMetadataCollection.metadata:type_name -> phonenumbers.PhoneMetadata
	20, // [20:20] is the sub-list for method output_type
	20, // [20:20] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_phonemetadata_proto_init() }
func file_phonemetadata_proto_init() {
	if File_phonemetadata_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_phonemetadata_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NumberFormat); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_phonemetadata_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PhoneNumberDesc); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_phonemetadata_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PhoneMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_phonemetadata_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PhoneMetadataCollection); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_phonemetadata_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_phonemetadata_proto_goTypes,
		DependencyIndexes: file_phonemetadata_proto_depIdxs,
		MessageInfos:      file_phonemetadata_proto_msgTypes,
	}.Build()
	File_phonemetadata_proto = out.File
	file_phonemetadata_proto_rawDesc = nil
	file_phonemetadata_proto_goTypes = nil
	file_phonemetadata_proto_depIdxs = nil
}
